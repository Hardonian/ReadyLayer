/**
 * Test Engine Service
 * 
 * Automatic test generation and coverage enforcement
 * Enforces coverage thresholds (minimum 80%)
 */

import { prisma } from '../../lib/prisma';
import { llmService, LLMRequest } from '../llm';
import { codeParserService } from '../code-parser';
import { queryEvidence, formatEvidenceForPrompt, isQueryEnabled } from '../../lib/rag';
import { checkBillingLimits } from '../../lib/billing-middleware';
import { policyEngineService } from '../policy-engine';
import { createHash } from 'crypto';
import { Issue } from '../static-analysis';

export interface TestGenerationRequest {
  repositoryId: string;
  prNumber?: number;
  prSha?: string;
  filePath: string;
  fileContent: string;
  framework?: string; // Auto-detect if not specified
  config?: TestConfig;
}

export interface TestConfig {
  coverageThreshold: number; // Minimum 80%, cannot go below
  metric: 'lines' | 'branches' | 'functions';
  enforceOn: 'pr' | 'merge' | 'both';
  failOnBelow: boolean; // REQUIRED: Always true, cannot disable
  placement: 'co-located' | 'separate' | 'mirror';
  testDir?: string;
}

export interface TestGenerationResult {
  id: string;
  status: 'generated' | 'failed' | 'blocked';
  testContent: string;
  placement: string;
  framework: string;
  startedAt: Date;
  completedAt: Date;
}

export interface CoverageResult {
  repositoryId: string;
  prNumber?: number;
  prSha?: string;
  coverage: {
    lines: { total: number; covered: number; percentage: number };
    branches: { total: number; covered: number; percentage: number };
    functions: { total: number; covered: number; percentage: number };
  };
  meetsThreshold: boolean;
  isBlocked: boolean;
}

export class TestEngineService {
  /**
   * Detect AI-touched files
   */
  async detectAITouchedFiles(
    _repositoryId: string,
    files: Array<{ path: string; content: string; commitMessage?: string; author?: string }>
  ): Promise<Array<{ path: string; confidence: number; methods: string[] }>> {
    const aiTouched: Array<{ path: string; confidence: number; methods: string[] }> = [];

    for (const file of files) {
      const methods: string[] = [];
      let confidence = 0;

      // Method 1: Check commit message
      if (file.commitMessage) {
        const commitMessage = file.commitMessage;
        const aiKeywords = ['copilot', 'cursor', 'claude', 'gpt', 'ai-generated', 'ai assisted'];
        if (aiKeywords.some((keyword) => commitMessage.toLowerCase().includes(keyword))) {
          methods.push('commit_message');
          confidence += 0.4;
        }
      }

      // Method 2: Check author
      if (file.author) {
        const aiAuthors = ['github-actions', 'copilot', 'cursor'];
        if (aiAuthors.some((author) => file.author?.toLowerCase().includes(author))) {
          methods.push('author');
          confidence += 0.3;
        }
      }

      // Method 3: Pattern analysis (simplified)
      const aiPatterns = [
        /\/\/ Generated by|# Generated by/i,
        /AI-?assisted|AI-?generated/i,
      ];
      if (aiPatterns.some((pattern) => pattern.test(file.content))) {
        methods.push('pattern');
        confidence += 0.3;
      }

      if (confidence >= 0.5) {
        aiTouched.push({
          path: file.path,
          confidence,
          methods,
        });
      }
    }

    return aiTouched;
  }

  /**
   * Generate tests for a file
   */
  async generateTests(request: TestGenerationRequest): Promise<TestGenerationResult> {
    const startedAt = new Date();

    // Validate config
    const config = request.config || this.getDefaultConfig();
    if (config.coverageThreshold < 80) {
      throw new Error('Coverage threshold cannot be below 80%. Minimum enforced: 80%');
    }

    if (config.failOnBelow === false) {
      throw new Error('fail_on_below cannot be disabled. Coverage enforcement is required.');
    }

    // Detect framework if not specified
    const framework = request.framework || (await this.detectFramework(request.repositoryId));

    try {
      // Parse code structure
      const parseResult = await codeParserService.parse(request.filePath, request.fileContent);

      // Get organization ID from repository
      const repo = await prisma.repository.findUnique({
        where: { id: request.repositoryId },
        select: { organizationId: true },
      });
      
      if (!repo) {
        throw new Error(`Repository ${request.repositoryId} not found`);
      }
      
      const organizationId = repo.organizationId;

      // Check billing limits before generating tests
      // Note: This is a service-level check. If called from webhook, billing is already checked.
      // But if called directly from API, we need to check here.
      // We'll check billing but not throw - let the caller handle the response.
      // For webhook calls, billing is checked upstream.
      const billingCheck = await checkBillingLimits(organizationId, {
        requireFeature: 'testEngine',
        checkLLMBudget: true,
      });
      if (billingCheck) {
        // Return error result instead of throwing
        return {
          id: `test_${Date.now()}`,
          status: 'blocked' as const,
          testContent: '',
          placement: '',
          framework: framework || 'unknown',
          startedAt,
          completedAt: new Date(),
        };
      }

      // Generate tests using LLM
      const prompt = await this.buildTestPrompt(
        request.filePath,
        request.fileContent,
        parseResult,
        framework,
        request.repositoryId,
        organizationId
      );

      const llmRequest: LLMRequest = {
        prompt,
        model: 'gpt-4-turbo-preview',
        organizationId: request.repositoryId, // Would get orgId from repo
        cache: true,
      };

      const response = await llmService.complete(llmRequest);
      const testContent = this.extractTestCode(response.content);

      // Validate test syntax
      await this.validateTestSyntax(testContent, framework);

      // Determine placement
      const placement = this.determinePlacement(request.filePath, config.placement, config.testDir);

      const completedAt = new Date();

      // Get organization ID for policy evaluation
      const repo = await prisma.repository.findUnique({
        where: { id: request.repositoryId },
        select: { organizationId: true },
      });
      
      if (!repo) {
        throw new Error(`Repository ${request.repositoryId} not found`);
      }
      
      const organizationId = repo.organizationId;

      // Load effective policy
      const policy = await policyEngineService.loadEffectivePolicy(
        organizationId,
        request.repositoryId,
        request.prSha,
        undefined
      );

      // Check if AI-touched file requires test generation (policy-based)
      const aiTouchedFiles = await this.detectAITouchedFiles(request.repositoryId, [
        { path: request.filePath, content: request.fileContent },
      ]);

      const findings: Issue[] = [];
      if (aiTouchedFiles.length > 0 && aiTouchedFiles[0].confidence >= 0.5) {
        // AI-touched file detected - evaluate risk
        findings.push({
          ruleId: 'test-engine.ai-touched',
          severity: 'high',
          file: request.filePath,
          line: 1,
          message: 'AI-touched file detected - test coverage required',
          fix: 'Ensure test coverage meets threshold',
          confidence: aiTouchedFiles[0].confidence,
        });
      }

      // Evaluate against policy
      const evaluationResult = policyEngineService.evaluate(findings, policy);

      // Save test result
      const test = await prisma.test.create({
        data: {
          repositoryId: request.repositoryId,
          prNumber: request.prNumber || null,
          prSha: request.prSha || null,
          filePath: request.filePath,
          framework,
          status: evaluationResult.blocked ? 'blocked' : 'generated',
          testContent,
          placement,
          startedAt,
          completedAt,
        },
      });

      // Produce evidence bundle
      const fileHash = createHash('sha256').update(request.fileContent, 'utf8').digest('hex');
      const timings = {
        totalMs: completedAt.getTime() - startedAt.getTime(),
      };
      await policyEngineService.produceEvidence(
        {
          fileHash,
          filePath: request.filePath,
          commitSha: request.prSha,
          prNumber: request.prNumber,
          aiTouched: aiTouchedFiles.length > 0,
        },
        {
          findings,
          evaluationResult,
          testGenerated: !evaluationResult.blocked,
        },
        policy,
        timings,
        { testId: test.id }
      );

      return {
        id: test.id,
        status: evaluationResult.blocked ? 'blocked' : 'generated',
        testContent,
        placement,
        framework,
        startedAt,
        completedAt,
      };
    } catch (error) {
      // Test generation failures MUST block PR
      throw new Error(
        `Test generation failed: ${error instanceof Error ? error.message : 'Unknown error'}. ` +
        `Cannot ensure test coverage for AI-generated code. ` +
        `This PR is BLOCKED until tests are generated.`
      );
    }
  }

  /**
   * Check coverage and enforce threshold (policy-aware)
   */
  async checkCoverage(
    repositoryId: string,
    prNumber: number,
    prSha: string,
    coverageData: any, // lcov or coverage JSON
    config?: TestConfig
  ): Promise<CoverageResult> {
    const testConfig = config || this.getDefaultConfig();

    // Parse coverage data
    const coverage = this.parseCoverage(coverageData);

    // Get organization ID for policy evaluation
    const repo = await prisma.repository.findUnique({
      where: { id: repositoryId },
      select: { organizationId: true },
    });
    
    if (!repo) {
      throw new Error(`Repository ${repositoryId} not found`);
    }

    // Load effective policy
    const policy = await policyEngineService.loadEffectivePolicy(
      repo.organizationId,
      repositoryId,
      prSha,
      undefined
    );

    // Check threshold
    const metric = coverage[testConfig.metric];
    const meetsThreshold = metric.percentage >= testConfig.coverageThreshold;

    // Create findings based on coverage
    const findings: Issue[] = [];
    if (!meetsThreshold) {
      findings.push({
        ruleId: 'test-engine.coverage-threshold',
        severity: 'high',
        file: 'coverage',
        line: 1,
        message: `Coverage ${metric.percentage.toFixed(1)}% below threshold ${testConfig.coverageThreshold}%`,
        fix: `Increase ${testConfig.metric} coverage to at least ${testConfig.coverageThreshold}%`,
        confidence: 1.0,
      });
    }

    // Evaluate against policy
    const evaluationResult = policyEngineService.evaluate(findings, policy);
    const isBlocked = evaluationResult.blocked || (!meetsThreshold && testConfig.failOnBelow);

    return {
      repositoryId,
      prNumber,
      prSha,
      coverage,
      meetsThreshold,
      isBlocked,
    };
  }

  /**
   * Build test generation prompt
   */
  private async buildTestPrompt(
    filePath: string,
    content: string,
    parseResult: any,
    framework: string,
    repositoryId: string,
    organizationId: string
  ): Promise<string> {
    // Query evidence if RAG is enabled
    let evidenceSection = '';
    if (isQueryEnabled()) {
      try {
        const evidenceQueries = [
          `similar files previously tested in repository ${repositoryId}`,
          `test framework conventions for ${framework}`,
          `test patterns for ${filePath}`,
        ];

        const allEvidence = [];
        for (const queryText of evidenceQueries) {
          const results = await queryEvidence({
            organizationId,
            repositoryId,
            queryText,
            topK: 3,
            filters: {
              sourceTypes: ['test_precedent', 'repo_file'],
            },
          });
          allEvidence.push(...results);
        }

        if (allEvidence.length > 0) {
          evidenceSection = formatEvidenceForPrompt(allEvidence);
        }
      } catch (error) {
        // Evidence retrieval failed - proceed without it (graceful degradation)
        console.warn('Evidence retrieval failed, proceeding without evidence:', error);
      }
    }

    return `Generate comprehensive tests for the following code using ${framework}.

File: ${filePath}

Code:
\`\`\`
${content}
\`\`\`

Functions to test:
${parseResult.functions.map((f: any) => `- ${f.name} (line ${f.line})`).join('\n')}
${evidenceSection}

Requirements:
1. Cover all functions and edge cases
2. Include error cases
3. Match existing test style if present
4. Use ${framework} syntax and best practices

Return only the test code, no explanations.`;
  }

  /**
   * Extract test code from LLM response
   */
  private extractTestCode(response: string): string {
    // Extract code blocks
    const codeBlockMatch = response.match(/```[\w]*\n([\s\S]*?)```/);
    if (codeBlockMatch) {
      return codeBlockMatch[1].trim();
    }

    // If no code block, return response as-is
    return response.trim();
  }

  /**
   * Validate test syntax
   */
  private async validateTestSyntax(testContent: string, framework: string): Promise<void> {
    // Simplified validation (would use actual parser in production)
    if (!testContent || testContent.length < 10) {
      throw new Error('Generated test is too short or empty');
    }

    // Basic syntax checks
    if (framework === 'jest' && !testContent.includes('describe') && !testContent.includes('test')) {
      throw new Error('Generated test does not match Jest syntax');
    }

    if (framework === 'pytest' && !testContent.includes('def test_')) {
      throw new Error('Generated test does not match pytest syntax');
    }
  }

  /**
   * Determine test file placement
   */
  private determinePlacement(
    filePath: string,
    placement: string,
    testDir?: string
  ): string {
    switch (placement) {
      case 'co-located':
        // Place next to source file
        return filePath.replace(/\.(ts|js|tsx|jsx)$/, '.test.$1');
      case 'separate':
        // Place in test directory
        const fileName = filePath.split('/').pop() || '';
        return `${testDir || 'tests'}/${fileName.replace(/\.(ts|js|tsx|jsx)$/, '.test.$1')}`;
      case 'mirror':
        // Mirror directory structure
        return filePath.replace(/^src\//, 'tests/').replace(/\.(ts|js|tsx|jsx)$/, '.test.$1');
      default:
        return filePath.replace(/\.(ts|js|tsx|jsx)$/, '.test.$1');
    }
  }

  /**
   * Detect test framework
   */
  private async detectFramework(_repositoryId: string): Promise<string> {
    // Would check repo config or package.json in production
    // Default to Jest for TypeScript/JavaScript
    return 'jest';
  }

  /**
   * Parse coverage data (lcov or JSON)
   */
  private parseCoverage(coverageData: any): CoverageResult['coverage'] {
    // Simplified parsing (would use proper lcov parser in production)
    if (typeof coverageData === 'object' && coverageData.lines) {
      return {
        lines: {
          total: coverageData.lines.total || 0,
          covered: coverageData.lines.covered || 0,
          percentage: coverageData.lines.percentage || 0,
        },
        branches: {
          total: coverageData.branches?.total || 0,
          covered: coverageData.branches?.covered || 0,
          percentage: coverageData.branches?.percentage || 0,
        },
        functions: {
          total: coverageData.functions?.total || 0,
          covered: coverageData.functions?.covered || 0,
          percentage: coverageData.functions?.percentage || 0,
        },
      };
    }

    // Default empty coverage
    return {
      lines: { total: 0, covered: 0, percentage: 0 },
      branches: { total: 0, covered: 0, percentage: 0 },
      functions: { total: 0, covered: 0, percentage: 0 },
    };
  }

  /**
   * Get default config (enforcement-first)
   */
  private getDefaultConfig(): TestConfig {
    return {
      coverageThreshold: 80, // Minimum 80%
      metric: 'lines',
      enforceOn: 'pr',
      failOnBelow: true, // REQUIRED: Cannot disable
      placement: 'co-located',
    };
  }
}

export const testEngineService = new TestEngineService();
